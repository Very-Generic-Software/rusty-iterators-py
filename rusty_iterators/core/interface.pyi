from __future__ import annotations

from collections.abc import Callable, Iterator
from typing import Any, Generic, Literal, Protocol, TypeAlias, final, overload

from rusty_iterators._versioned_types import Self, TypeVar, override
from rusty_iterators.lib._async import AsyncIterAdapter

T = TypeVar("T", default=Any, covariant=True)
R = TypeVar("R", default=Any, covariant=True)

FilterCallable: TypeAlias = Callable[[T], bool]
MapCallable: TypeAlias = Callable[[T], R]

class BuildableFromIterator(Protocol[T]):
    def __init__(self, iterator: Iterator[T]) -> None: ...

class IterInterface(Generic[T]):
    def __iter__(self) -> Self: ...
    def __next__(self) -> T: ...
    def as_async(self) -> AsyncIterAdapter[T]: ...
    def can_be_copied(self) -> bool: ...
    def collect(self) -> list[T]: ...

    F = TypeVar("F", bound=BuildableFromIterator[T])

    @overload
    def collect_into(self, factory: type[tuple[T, ...]]) -> tuple[T, ...]: ...
    @overload
    def collect_into(self, factory: type[list[T]]) -> list[T]: ...
    @overload
    def collect_into(self, factory: type[set[T]]) -> set[T]: ...
    @overload
    def collect_into(self, factory: type[frozenset[T]]) -> frozenset[T]: ...
    @overload
    def collect_into(self, factory: type[F]) -> F: ...
    def copy(self) -> Self: ...
    def filter(self, func: FilterCallable[T]) -> Filter[T]: ...
    def map(self, func: MapCallable[T, R]) -> Map[T, R]: ...
    @overload
    def cycle(self, use_cache: Literal[False]) -> CopyCycle[T]: ...
    @overload
    def cycle(self, use_cache: Literal[True] = True) -> CacheCycle[T]: ...
    def next(self) -> T: ...

@final
class Filter(IterInterface[T], Generic[T]):
    def __init__(self, other: IterInterface[T], func: FilterCallable[T]) -> None: ...
    @override
    def can_be_copied(self) -> bool: ...
    @override
    def copy(self) -> Filter[T]: ...
    @override
    def next(self) -> T: ...

@final
class Map(IterInterface[R], Generic[T, R]):
    def __init__(self, it: IterInterface[T], func: MapCallable[T, R]) -> None: ...
    @override
    def can_be_copied(self) -> bool: ...
    @override
    def copy(self) -> Map[T]: ...
    @override
    def next(self) -> R: ...

@final
class CacheCycle(IterInterface[T], Generic[T]):
    def __init__(self, it: IterInterface[T]) -> None: ...
    @override
    def can_be_copied(self) -> bool: ...
    @override
    def copy(self) -> CacheCycle[T]: ...
    @override
    def next(self) -> T: ...

@final
class CopyCycle(IterInterface[T], Generic[T]):
    def __init__(self, it: IterInterface[T]) -> None: ...
    @override
    def can_be_copied(self) -> bool: ...
    @override
    def copy(self) -> CopyCycle[T]: ...
    @override
    def next(self) -> T: ...
